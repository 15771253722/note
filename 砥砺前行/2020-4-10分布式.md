# 											分布式

## 1.为什么要用分布式？

​	首先想到的就是“解耦”，互联网行业飞速发展，大型网站的业务逻辑也日趋复杂。所以，人们想到了“分而治之”即将整个项目拆分成多个不同的应用，交由不同的业务团队开发，各自独立部署维护。它们之间可以通过一个超链接建立关系、也可以通过消息队列进行数据分发，最多的还是通过一个数据存储系统来构成一个关联的完整系统。

​	但是，随着应用越来越多，拆分越来越小，存储系统越来越大，应用的复杂度上升，维护越来越困难，所有的应用都要与数据库相连，数据库压力太大，无法服务。仔细观察，可以发现，很多应用中会执行相同的业务，把这些业务提取出来，独立部署成公共业务（集群）。其他业务通过分布式服务调用公共业务服务，这些可复用的公共业务操作数据库，完成具体业务。

​	为了网站的扩展性（核心思想：模块化）：对现有系统影响最小，提升系统功能或者可持续扩展。降低模块间耦合：分布式部署，独立模块独立部署（物理解耦）；模块间调用采用分布式消息队列（解耦，异步，削峰填谷）。

​	分布式服务（降低系统耦合性）：如果说分布式消息队列是通过消息对象分解系统耦合性：不同的子系统处理同一个消息；那么分布式服务就是通过接口分解系统耦合性：不同的子系统通过相同的接口描述进行服务调用。例如Dubbo：服务框架客户端模块通过服务注册中心加载服务提供者列表（服务提供者启动后主动向服务注册中心注册自己可提供的服务接口列表），查找需要的服务接口，并根据配置的负载均衡策略将服务调用请求发送到某台服务提供者服务器。如果服务调用失败，客户端模块会自动从服务提供者列表选择一个可提供同样服务的另一台服务器重新请求服务，实现服务的自动失效转移，保证高可用服务。

​	**扩展内容**

​		**架构层面演化：单体架构--->SOA架构--->微服务架构**	

- 单体架构：项目过于臃肿，维护成本高，bug难定位；资源共享（一处出错，整个系统性能受影响）；无法针对性的扩展性能（订单系统瓶颈，扩展整个项目性能！）；完成周期长（所有功能一起上线，一起构建，一起部署）。
- SOA架构：松耦合、通常经过ESB（企业服务总线：面向服务的架构---分布式的应用由可重复的服务组成、面向消息的架构---应用间通过ESB发送和接收消息、时间驱动的架构---应用间的异步产生和接收消息）进行系统集成、大团队（100-200人）、TTM（1月-1年）、集中式计划内停机扩容。
- 微服务架构：解耦、小团队、TTM（天或周）、可扩展性、高可用：升级、扩容不中断业务。

## 2.分布式的缺点

1. 性能：分布式系统是跨进程、跨网络的，很受网络延迟和宽带的影响。
2. 可靠性：由于高度依赖网络状况，任何一次远程调用都可能失败。
3. 异步：引入各种中间间，异步通信大大增加了功能实现的复杂程度。
4. 数据一致性：分布式系统必然会导致分布式事务的出现，此时，必须在C（一致性）A（可用性）P（分区容错性）之间做出取舍（zookeeper是CP，eureka是AP）。
5. 运维成本：一个系统被拆分成多个服务，各自都要独立配置、部署、监控、日志处理等。

## 3.分布式锁

### 1.为什么要用分布式锁？

​	分布式集群、微服务--->多台服务器--->资源共享--->并发

​	synchronized关键字和ReentrantLock的互斥控制只能对同一个进程下的线程加锁，分布式系统多线程、多进程且分布在不同机器上，所以原JAVA并发处理相关API策略失效，需要一种跨JVM的互斥机制来控制共享资源的访问！

### 2.分布式锁的三种实现

​	在分布式系统的环境下，一个方法在同一时间只能被一台机器的一个线程执行。

1. 高可用的获取锁与释放锁
2. 高性能的获取释放锁
3. 具备可重入特性
4. 具备锁失效机制，防止死锁
5. 具备阻塞锁特性，即没有获取锁将继续等待获取锁
6. 具备非阻塞锁特性，即没有获取锁，直接返回获取锁失败

- 基于数据库的实现方式

  ​	在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

  ​	**优化**：

  1. 数据库的可用性和性能直接影响分布式锁的可用性及性能，所以，数据库双机部署、数据同步、主备切换。

  2. 不具备可重入的特性：因为同一个线程在线程释放锁之前，行数据一直存在，无法再次插入数据，所以，想要在表中新增一列，用于记录当前获取锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器的线程相同，若相同则直接获取锁。

  3. 没有锁失效机制：有可能成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务回复后，一直拿不到锁。所以，表中新增一列，记录失效时间，并且有定时任务定期清理这些失效数据。

  4. 不具备阻塞锁特性：回去不到锁，直接返回失败，使用循坏，让它多次去获取。

     **优点：**借助数据库，方案简单。

     **缺点：**实际过程中会遇到各种不同的问题，实现方案会越来越复杂。

- 基于redis实现

  ​	使用setnx命令设置key-value，并设置过期时间，使用del命令释放分布式锁。在Redis2.6.12版本中实现了这个功能，Redis为set命令增加了一系列选项，可以通过SET resource_name my_random_value NX PX max-lock-time来获取分布式锁，这个命令仅在不存在key(resource_name)的时候才能被执行成功（NX选项），并且这个key有一个max-lock-time秒的自动失效时间（PX属性）。这个key的值是“my_random_value”，它是一个随机值，这个值在所有的机器中必须是唯一的，用于安全释放锁。

  **问题：**

  1. 为了实现高可用，采用主从复制，主从复制时异步的，会出现数据不同步的问题，可能导致多个机器的多个线程获取到同一个锁。
  2. 程序出现异常，无法正常释放锁。

  **优化：**

  1. 不采用主从复制，使用RedLock算法。有个成熟的高效、高可用的开源分布式锁实现：Redisson。

  2. try---finally语句，最后一定要删除lock。

     **优点：**高性能，借助Redis实现比较方便。

     **缺点：**线程获取锁后，如果处理时间过长会导致锁超时失效，所以，通过锁超时机制不是很可靠。

- 基于zookeeper实现

  ​	zookeeper是一个为分布式应用提供一致性服务的开源组件，他的内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。

  1. 创建一个目录mylock；

  2. 线程A想获取锁就在mylock目录下创建临时顺序节点；

  3. 获取mylock目录下的所有子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；

  4. 线程B获取所有节点，判断自己不是最小节点，设置监听比自己次序小的节点；

  5. 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小节点，如果是，则拿到锁。

     这里推荐一个apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。

     **优点：**具备高可用、可重入、阻塞锁特征，可以解决失效死锁问题。

     **缺点：**需要频繁的创建和删除节点，性能上不如Redis方式。

**总结：**没有最好的实现方式，根据场景，自己选择最合适的实现方式！