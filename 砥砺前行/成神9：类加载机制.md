# JVM虚拟机：类加载机制

Class文件中存储了类（和接口）中的元数据信息和编译后的字节码。这些信息需要存入Java虚拟机中才能被虚拟机利用和执行。而Class文件时需要Java虚拟机内存中的。这就涉及到几个问题，什么时候需要加在一个Class文件？虚拟机如何加载Class文件到虚拟机内存中？Class文件中的信息进入虚拟机内存中后会发生怎么样的变化？

## 1.概述

虚拟机把描述类的数据从Class文件加载到虚拟机内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

与那些在编译时需要 进行连接工作的语言不同，在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这可能会导致类加载时增加了性能开销，不过这也是为Java程序提供了高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。这个特性导致了很多有用的功能的出现，比如，可以编写一个面向接口的应用程序，等到运行时再指定接口的实现类；用户可以通过Java预定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或者其他地方加载一个二进制流作为程序代码的一部分。

## 2.什么时候加载？

类的一生就是从被加载到虚拟机内存开始，直到卸载出内存为止。整个生命周期中，一个类经历了加载（Loading）、验证（Verfication）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）等七个阶段。其中，验证、准备、解析三个阶段称为连接（Linking）。但是解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也叫动态绑定和晚期绑定）。

接下来就应该考虑一个Class文件会在什么时候进行加载。Java虚拟机规范中并没有进行强制约束，由虚拟机来具体实现。不过对于类的初始化阶段，虚拟机规范严格规定了5种情况下必须对类进行初始化，这样，类的加载、验证、准备就在这之前开始了。

- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，就需要进行类的初始化。这些场景包括：使用new关键字实例化对象时、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）时，以及调用一个类的静态方法时；
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，就需要先进行类的初始化；
- 当初始化一个类的时候，如果发现父类还没有进行过初始化，则需要先初始化父类；
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类；
- 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

这五种情况是Java虚拟机规范规定的主动初始化一个类的情况，除此之外的任何其他引用一个类的情况都不会主动初始化这个类，这叫做被动引用。

1. 通过子类引用父类的静态字段，并不会初始化子类。
2. 通过数组定义来引用类，不会触发此类的初始化。
3. 常量在编译阶段会存入调用类的常量池。

## 3.怎么加载？

加载、验证、准备、解析和初始化。

### 1.加载阶段

- 通过一个类的全限定名来获取定义这个类的二进制字节流；

- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；

- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

  ![1589354758603](C:\Users\14579\AppData\Local\Temp\1589354758603.png)

首先要有Class文件。虽然说是文件，但获取Class二进制流的方式非常多，只要能得到这个虚拟机所需要的内容即可。比如可以使用如下的方式获取二进制流：

- 从ZIP包中读取，这就是JAR、EAR和WAR格式的基础；
- 从网络中获取，典型应用就是Applet；
- 运行时计算生成，使用最多的就是动态代理技术；
- 由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类；
- 从数据库汇中读取；

总之，获取Class文件的方式非常多。------>类加载器------>需要注意的是，加载阶段与连接阶段的部分内容是交叉进行的。

### 2.验证阶段

验证阶段是虚拟机的自我保护的一个手段。

从整体上看，验证阶段大致可以分为四个方面：文件格式验证、元数据验证、字节码验证和符号引用验证。

### 3.准备阶段

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中需要注意两点，首先，这个时候进行内存分配的仅包括类变量（被static修饰的变量）而不包括实例变量，实例变量就在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值通常是数据类型的零值。

### 4.解析阶段

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，在Class文件结构中层多次提到过符号引用，它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。在解析阶段的符号引用和直接引用的区别如下：

- 符号引用（Symbolic References）：符号引用以一组符号来描述索引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用都是一样的；
- 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局有关的，同一个符号引用在不同的虚拟机上翻译出来的直接引用一般不相同。如果有了直接引用，那么引用的目标一定在内存中。

### 5.初始化阶段

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序。

## 4.类加载器

类加载的过程是通过类加载器来完成的。类加载器是Java语言的一个重要创新，许多有用的技术都是基于类加载器实现的，比如类层次划分、OSGi、热部署、代码加密等。

### 1.类与类加载器

虽然类加载器只用于类的加载动作，但在Java程序中还有着很大的作用。对于任意一个类，都需要加载它的类加载器和这个类本身来确定这个类在Java虚拟机中的唯一性，每一个类加载器都有一个独立的类名称空间。也就是说，如果比较两个类是否是同一个类，除了这比较这两个类本身的全限定名是否相同之外，还要比较这两个类是否是同一个类加载器加载的。即使同一个类文件两次加载到同一个虚拟机中，但如果是由两个不同的类加载器加载的，那这两个类仍然不是同一个类。（instanceof检查）

### 2.双亲委派模型

从Java虚拟机的角度看，只有两种不同的类加载器，一种是启动类加载器，这个类加载是由C++实现的，是虚拟机的一部分；另一个是所有其它的类加载器，都是由Java实现的，独立在虚拟机外部，并且全部继承自java.lang.ClassLoader抽象类。

不过在Java开发者看来，类加载器的细致划分可以划分为三种：

- 启动类加载器：负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。
- 扩展类加载器：这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器：这个类加载器是由sun.misc.Launcher$AppClassLoader实现的。由于这个类加载器是ClassLoader中的getSystemClassLoader方法的返回值，所以也叫系统类加载器。它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。