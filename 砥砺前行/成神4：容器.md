# 语言基础：容器

## 1.Collection：存放独立元素

Collection中的接口都是可选操作，其实现类并不一定实现了其所有接口，这是为了防止“接口爆炸”。最常见的Unsupported Operation都源自于背后由固定尺寸的数据结构支持的容器，比如使用ArrayList.asList将数组转换成List的时候，就会得到这样的容器。

### 1.Collection之List

List较之Collection增加了很多额外的接口。特别是LinkedList。

|            |                             优点                             |                          缺点                          | 保存的元素顺序 |                应用                |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------: | :------------: | :--------------------------------: |
| ArrayList  |              随机访问速度快，内部使用数组实现。              | 迭代，插入和删除元素慢，尤其是当List尺寸比较大的时候。 |    插入顺序    |             可变长数组             |
| LinkedList | 迭代（顺序访问经过优化），插入，删除都很快。内部使用双向链表实现。 |                     随机访问速度慢                     |    插入顺序    | 顺序访问，批量插入删除元素的场合。 |

### 2.Collection之Set

存入Set的每一个元素都必须是唯一的，因为Set不保存重复元素，但是存入Set的元素必须要定义equals()方法以确保对象的惟一性。另外Set与Collection有着完全相同的接口，Set并不保证维护元素的次序。所以需要注意，Set不包含随机访问的get方法，因为Set是自己维护内部顺序的，不需要随机访问。

|               |                             优点                             |          保存元素的顺序          |                    要求                     |
| :-----------: | :----------------------------------------------------------: | :------------------------------: | :-----------------------------------------: |
|    HashSet    |                        为快速查找设计                        |             散列存储             |           必须定义hashCode()方法            |
| LinkedHashSet | 和HashSet一样查询速度，但是插入要比HashSet慢一些，因为它通过维护链表形式维护元素。 | 使用链表维护元素顺序（插入顺序） |           必须定义hashCode()方法            |
|    TreeSet    |            保存有序的Set，底层通过TreeMap来实现。            |       按照排序顺序维护元素       | 必须实现Comparable接口（包含compareTo方法） |

注意，如果没有特别的限制，HashSet就应该是你的默认选择，因为它对速度进行了优化。

### 3.Collection之Queue

|               |                             特点                             | 保存元素顺序 |
| :-----------: | :----------------------------------------------------------: | :----------: |
|  LinkedList   | LinkedList除了普通List之外，还添加了很多实现<队列，栈，双向队列>三种数据结构的方法。尤其是模拟Queue的时候在俩端插入删除元素很快（经过了优化）。 |  插入的顺序  |
| PriorityQueue |    按照排序顺序取出元素，所以要求必须实现Comparable接口。    |   排序顺序   |

## 2.Map：存放键-值对

为了保证Map中的唯一性，任何“键”都需要有一个equals（）方法，判断当前键是否与表中的键相同。

|               |                             特点                             | 保存元素的顺序 |                             要求                             |
| :-----------: | :----------------------------------------------------------: | :------------: | :----------------------------------------------------------: |
|    HashMap    |     Map基于散列存储，插入和查询“键值对”的开销是固定的。      |    散列存储    | 存入的键需要具备hashCode（）方法，当然，返回的标识不一定要唯一。 |
| LinkedHashMap | 为了提高速度散列了所有元素，插入查询只比HashMap慢一点点，因为它在维护散列数据结构的同时还要维护链表(插入顺序)。 但是迭代访问的时候更快，因为内部使用链表维护次序。 |    插入顺序    |                 同样需要键实现hashCode()方法                 |
|    TreeMap    |      Map基于红黑树的实现。所以所得的结果是经过排序的。       |     红黑树     |               为了排序，必须实现Comparable接口               |

## 3.总结

（1）要想让你的容器类型安全，需要使用泛型（否则编译器允许你向容器中插入各种不同类型，只要是Object即可）；

（2）创建容器的时候尽量将其向上转型为接口，像这样：

List<Apple> apples = newArrayList<Apple>();

   使用接口的目的在于当你决定修改你的实现的时候，只需要在创建的地方修改它就可以了。

（3）Java有大量的用于容器的卓越的方法，他们被封装到java.util.Collections类中，全部都是static方法。比如Collections类中有unmodifiableMap/List/Set()方法设置Collection和Map为不可修改，还有synchronizedCollection/List/Set/Map等方法同步整个容器。另外排序，填充，逆置，最大最小值等很多方法也可以找到。