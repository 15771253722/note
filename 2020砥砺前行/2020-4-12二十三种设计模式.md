# 						二十三种设计模式

## 1.单例模式

​	懒汉（先创建对象new Singleton 私有化构造函数 private singleton get对象，返回对象）然后有人就说了，你这浪费资源啊，一直创建对象。--->饿汉（对象先声明出来，私有化构造函数，对外提供方法，首先判断对象是不是为空，为空 new一个）--->你这有线程安全问题啊->方法上synchronized，类锁。--->你这锁的也太大了！--->对象锁->不解决问题--->DCL双重校验。

## 2.观察者模式

​	当一个对象发生变化时，其他依赖该对象的对象都会收到通知，并且随着变化，一对多关系（类似于邮箱订阅）。

## 3.装饰模式

​	给一个对象增加些新功能，而且时动态的要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。代理模式在编译时就已经被确定了，装饰模式在运行时递归的构造。代理模式可以隐藏一个对象的具体信息。（代理模式在代理类中创造一个对象的实例）。装饰器模式更关注一个对象的动态添加方法而代理可以隐藏一个对象的具体信息。