# 分布式事务

## 一.由来

解析它的名字来理解：

​	**事务**：最先想到的就是它的特性：ACID

​		A：原子性---事务不可分割，不会存在有部分事务执行，有部分事务没执行。

​		C：一致性---事务操作过程中不会存在中间状态。例如，我消费了100块，你赚了100块。不会存在--->我扣了钱你没收钱；或者我没扣钱你收了钱的这种中间状态。

​		I: 隔离性---事务之间互不影响

​		D：持久性---事务操作一旦完成，结果永久改变。

​	**分布式**：数据存储在多节点上，这就会导致一种情况：原本在单机上面很好实现的ACID特性在分布式的环境下就会变得特别困难。

​		1.因为网络通信的不可靠，事务的原子性需要用多次日志和网络通信来保证。

​		2.存储节点的增加，放大了单个存储节点在事务过程中出现故障的风险。

​		3.用锁实现的事务隔离性，在故障或网络抖动时严重影响性能。

## 二.解决方案

### 1.俩阶段提交（2PC）

通过引入协调者来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。

#### 1.1运行过程

##### 1.1.1准备阶段

协调者询问参与者事务是否执行成功，参与者返回事务执行结果。

![](C:\Users\14579\Pictures\笔记图\俩阶段提交-准备.jpg)

##### 1.1.2提交阶段

如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。

需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接受到协调者发来的通知后，才进行提交或者回滚。

![](C:\Users\14579\Pictures\笔记图\运行过程-提交阶段.jpg)



#### 1.2存在的问题

##### 1.2.1同步阻塞

所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其他操作。

##### 1.2.2单点问题

协调者在2PC中起到非常大的作用，发生故障将会造成很大的影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其他操作。

##### 1.2.3数据不一致

在二阶段，如果协调者只发送了部分Commit消息，此时网络发生异常，那么只有部分参与者接受到Commit消息，也就是说只有参与者提交了事务，使得系统数据不统一。

##### 1.2.4太过保守

任意一个节点失败就会导致整个事务失败，没有完善的容错机制。

### 2.补偿事务（TCC）

TCC其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

- Try阶段主要是对业务系统做检测及资源预留
- Confirm阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行Confirm阶段时，默认Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
- Cancel阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

例如，Bob要给Smith转账

1.把钱都冻起来

2.转账操作，成功解冻。

3.失败，调用预备资源回滚数据，调用2的解冻方法。

![](C:\Users\14579\Pictures\笔记图\TTC.jpg)

**优点**：跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也差了一些。

**缺点**：缺点还是比较明显的，在2.3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。

### 3.本地消息表（异步确保）

本地消息表与业务数据表处于同一数据库中，这样就能利用本地事务来保证对这俩个表的操作满足事务要求，并且使用消息队列来保证最终一致性。

​	3.1在分布式事务操作的一方完成写业务数据的操作之后向本地信息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。

​	3.2之后将本地消息表中的消息转发到Kafka等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。

​	3.3在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。

![](C:\Users\14579\Pictures\笔记图\本地消息表-异步确保.jpg)

**优点**：一种非常经典的实现，避免了分布式事务，实现的是事务的最终一致性。

**缺点**：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

### 4.MQ事务消息

有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如RabbitMQ和Kafka都不支持。

以阿里RocketMQ中间件为例，其大致实现思路为：

第一阶段Prepared消息，会拿到消息地址---->第二阶段执行本地事务---->通过第一阶段拿到的地址去访问消息，并修改状态。

也就是说在业务方法内要想消息队列提交俩次请求，一次发送消息和一次确认信息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，他会想消息发送者确认。所以生成方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同事成功或同时失败。

![](C:\Users\14579\Pictures\笔记图\MQ事务消息.jpg)



RocketMQ 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。

第一步先给 Broker 发送事务消息即半消息，**半消息不是说一半消息，而是这个消息对消费者来说不可见**，然后**发送成功后发送方再执行本地事务**。

再根据**本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令**。

并且 RocketMQ 的发送方会提供一个**反查事务状态接口**，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。

如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。

如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。

可以看到通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。

![](C:\Users\14579\Pictures\笔记图\事务消息.jpg)



**优点**：实现了最终一致性，不需要依赖本地数据库事务。

**缺点**：实现难度大，主流MQ不支持，RockertMQ事务消息部分代码也没有开源。

### 5.三阶段提交

首先**准备阶段的变更成不会直接执行事务**，而是会先去询问此时的参与者是否有条件接这个事务，因此**不会一来就干活直接锁资源**，使得在某些资源不可用的情况下所有参与者都阻塞着。

而**预提交阶段的引入起到了一个统一状态的作用**，它像一道栅栏，表明在预提交阶段前所有参与者其实还未都回应，在预处理阶段表明所有参与者都已经回应了。

假如你是一位参与者，你知道自己进入了预提交状态那你就可以推断出来其他参与者也都进入了预提交状态。

但是多引入一个阶段也多一个交互，因此**性能会差一些**，而且**绝大部分的情况下资源应该都是可用的**，这样等于每次明知可用执行还得询问一次。

我们再来看下参与者超时能带来什么样的影响。

我们知道 2PC 是同步阻塞的，上面我们已经分析了协调者挂在了提交请求还未发出去的时候是最伤的，所有参与者都已经锁定资源并且阻塞等待着。

那么引入了超时机制，参与者就不会傻等了，**如果是等待提交命令超时，那么参与者就会提交事务了**，因为都到了这一阶段了大概率是提交的，**如果是等待预提交命令超时，那该干啥就干啥了，反正本来啥也没干**。

然而超时机制也会带来数据不一致的问题，比如在等待提交命令时候超时了，参与者默认执行的是提交事务操作，但是**有可能执行的是回滚操作，这样一来数据就不一致了**。

这个了解即可，2PC问题还是在的，感觉就是个理论上的东西。

### 6.最大努力通知

本地消息表和事务消息可以算为最大努力通知表，这个方法的机制就是定时扫描那些长期处理不掉的数据。当一个消息多次调用都失败的时候，可以将它记录下来转去人工处理，或者直接舍弃调。

事务消息也是一样，当半的消息被commit了之后确实就是普通消息了，如果订阅者一直不消费这条消息，当重复到一定的次数后，将它变成死信队列。

**死信队列**：普通消息--->死信消息--->死信队列--->统一处理：丢弃，用表记录它们等操作

核心思想：尽最大的努力去实现事务的最终一致性！

## 三.总结：

分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择吧。阿里RocketMQ去实现的分布式事务，现在也有除了很多分布式事务的协调器，比如LCN等。