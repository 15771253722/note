# 数据库：索引慢

## 一.表分析走的是全表扫描，没走索引

1. 索引列有隐式转换，不走索引
2. 索引列倾斜，个别值查询时，走索引代价比走全表扫描更高，不走索引
3. 索引列没有限制 not null，因索引不存储空值，如果不限制索引列是not null，[oracle](http://www.itpub.net/tree/index_1/)会认为索引列有可能存在空值，所以不会按照索引计算。
4. "a.name like '%a'"是尾部匹配,需索引扫描(index scan).
5. "select *"将返回所有字段,不利于索引的使用.
6. 当需返回记录数大于总记录数20%时,不使用索引.（满足条件*的行数*/总行数<=0.7181,会走索引.）
7. 如果[table]表是小表时,不需使用索引.

## 二.用了索引，还是很慢

1. 全索引扫描的不足

   根据叶子节点内容不同,索引类型分为主键索引和非主键索引.
   **主键索引**也被称为聚簇索引,**叶子节点存放的是整行数据**; 而**非主键索引**被称为二级索引,**叶子节点存放的是主键的值**.
   如果根据主键查询, 只需要搜索ID这颗B+树
   而如果通过非主键索引查询, 需要先搜索k索引树, 找到对应的主键, 然后再到ID索引树搜索一次, 这个过程叫做回表.
   **总结, 非主键索引的查询需要多扫描一颗索引树, 效率相对更低.**

2. 索引的过滤性要足够好

3. 从索引上用树搜索，取到第1个age等于10的记录，得到它的主键id的值，根据id的值去主键索引取整行的信息，作为结果集的一部分返回；

   

   在索引age上向右扫描，取下一个id的值，到主键索引上取整行信息，作为结果集的一部分返回；

   

   重复上面的步骤，直到碰到第1个age大于15的记录；

   你看这个语句，虽然他用了索引，但是他扫描超过了1亿行。所以你现在知道了，当我们在讨论有没有使用索引的时候，其实我们关心的是扫描行数。

   **对于一个大表，不止要有索引，索引的过滤性还要足够好。**

   像刚才这个例子的age，它的过滤性就不够好，在设计表结构的时候，我们要让所有的过滤性足够好，也就是区分度足够高。

   ​                   再说白点：sql特征不好！！！

4. 回表的代价

   select * from t_people where name like '张%' and age=8;

   这个sql特征好了，但是用了模糊查询，回表次数多了，也就慢了。

5. 虚拟列

   可以看到这个优化的效果还是很不错的，但是这个优化还是没有绕开最左前缀原则的限制，因此在联合索引你还是要扫描8000万行，那有没有更进一步的优化方法呢？

   我们可以考虑把名字的第一个字和age来做一个联合索引。这里可以使用MySQL5.7引入的虚拟列来实现。对应的修改表结构的SQL语句:select * from t_people where name_first='张' and age=8

   新建一列，就叫 姓  然后建索引查询，就快了！

6. 总结：

   - 全表扫描
   - 全索引扫描
   - 索引过滤性不好
   - 频繁回表的开销