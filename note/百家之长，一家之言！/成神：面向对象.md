# 第二步：面向对象

## 1.对象与内存

new 关键字表示创建一个对象
new 关键字表示实例化对象
new 关键字表示申请内存空间
注意：如果使用一个没有申请内存空间的对象，会报空指针异常：java.lang.NullPointerException

![1589165101387](C:\Users\14579\AppData\Local\Temp\1589165101387.png)

![1589165128813](C:\Users\14579\AppData\Local\Temp\1589165128813.png)

![1589165155896](C:\Users\14579\AppData\Local\Temp\1589165155896.png)

![1589165181255](C:\Users\14579\AppData\Local\Temp\1589165181255.png)

（1）new关键字：表示向内存申请空间，也表示实例化一个对象，创建一个对象。
（2）一个对象在内存中的大小，由该对象的所有属性所占的内存大小的总和。引用类型变量在32位系统上占4个字节，在64位系统上占8个字节。加上而外的对象隐性数据所占的大小。
（3）相同的类型才可以赋值
（4）不同的引用，指向同一个对象，任何一个引用改变对象的值，其它引用都会反映出来。
（5）编程时要注意的问题，在确定不使用对象时，要尽早释放对象：引用=null
（6）当一个堆中的对象没有被任何引用变量所指向时，该对象会被JVM 的 GC 程序认为是垃圾对象，从而被回收

##  2.封装性

封装性是面向对象思想的三大特征之一，封装就是隐藏实现细节，仅对外提供访问接口。实现细节部份包装、隐藏起来的方法。
封装有：属性的封装、方法的封装、类的封装、组件的封装、模块化封装、系统级封装…
封装的好处：模块化、信息隐藏、代码重用、插件化易于调试、具有安全性
封装的缺点：会影响执行效率

成员变量和局部变量的区别
a、在类中的位置不同
成员变量：在类中定义
局部变量：在方法中定义或者方法的参数
b、在内存中的位置不同
成员变量：在堆内存(成员变量属于对象，对象进堆内存)
局部变量：在栈内存(局部变量属于方法，方法进栈内存)
c、生命周期不同
成员变量：随着对象的创建而存在，随着对象的销毁而消失
局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
d、初始化值不同
成员变量：有默认初始化值，引用类型默认为null
局部变量：没有默认初始化值，必须定义，赋值，然后才能使用
注意：
局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。

## 3.构造方法

无参、带参和多参构造方法。

（1）构造方法名称与类名相同，没有返回值声明（包括 void）
（2）构造方法用于初始化数据（属性）
（3）每一个类中都会有一个默认的无参的构造方法
（4）如果类中有显示的构造方法，那么默认构造方法将无效
（5）如果有显示的构造方法，还想保留默认构造 方法，需要显示的写出来。
（6）构造方法可以有多个，但参数不一样，称为构造方法的重载
（7）在构造方法中调用另一个构造方法，使用this(...)，该句代码必须在第一句。
（8）构造方法之间的调用，必须要有出口。
（9）给对象初始化数据可以使用构造方法或setter方法，通常情况下，两者都会保留。
（10）一个好的编程习惯是要保留默认的构造方法。（为了方便一些框架代码使用反射来创建对象）
（11）private Dog(){}，构造方法私有化，当我们的需求是为了 保正该类只有一个对象时（单例模式就是私有化构造器）。

## 4.this关键字

this关键字指向的是当前对象的引用
调用类中的属性：this.属性名称，指的是访问类中的成员变量，用来区分成员变量和局部变量（重名问题）
调用类中的方法：this.方法名称，用来访问本类的成员方法
调用类构造方法：this();访问本类的构造方法，()中可以有参数的 如果有参数 就是调用指定的有参构造
注意：
1.this() 不能使用在普通方法中，只能写在构造方法中
2.必须是构造方法中的第一条语句

## 5.值传递和引用传递

**首先，注意：在java中只有按值传递，并没有所谓的按引用传递**
java数据类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。

![1589165693810](C:\Users\14579\AppData\Local\Temp\1589165693810.png)

注：

**原来引用类型的按值传递，传递的是对象的地址。**

![1589166489212](C:\Users\14579\AppData\Local\Temp\1589166489212.png)

## 6.对象的一对一关系

```java
class Hero {
　　private String name; //属性私有化 ，防止外面直接赋值和调用
　　private int age;
　　private Weapon weapon; //声明一个武器类的对象 (私有化)
　　//此处省略get，set方法和构造器
}

class Weapon {
　　private String name;
　　private int age;
　　private Hero hero; //声明一个对象
　　//此处省略get，set方法和构造器
}

public class One2One {
　　public static void main(String[] args) {
　　　　Hero hero = new Hero("刘备",35); //实例化一个对象，并且赋值
　　　　Weapon weapon = new Weapon("双股剑",3);
　　　　//建立关系 ，（一句代码搞定）
　　　　hero.setWeapon(weapon); //把武器类对象设置成英雄类中的一个属性
　　　　weapon.setHero(hero);
　　　　//输出结果，用英雄类查找其武器
　　　　System.out.println("我的名字叫"+hero.getName()+"，我现在"+hero.getAge()+"岁了，我用的武器是"+w.getName()+",等级为"+w.getAge()+"级。");
　　　　//我的名字叫刘备，我现在35岁了，我用的武器是双股剑,等级为3级。

　　　　hero.setAge(350); //修改其属性
　　　　weapon.setName("生锈的双股剑");
　　　　weapon.setAge(2);

　　　　//Hero h = weapon.getHero();
　　　　//用武器查找其主人
　　　　System.out.println("我是"+weapon.getName()+",我的等级已经降落为"+weapon.getAge()+"级了，我的主人是"+weapon.getHero().getName()+",现在已　　　　　　经"+weapon.getHero().getAge()+"岁了");
　　　　//我是生锈的双股剑,我的等级已经降落为2级了，我的主人是刘备,现在已经350岁了

}
```

## 7.static关键字

static关键字的作用：方便在没有创建对象的情况下来进行调用（方法/变量）。
a、使用static关键字修饰一个属性：声明为static的变量实质上就是全局变量
b、使用static关键字修饰一个方法：在一个类中定义一个方法为static，那就是说，无需本类的对象即可调用此方法（类调用）
c、使用static关键字修饰一个类（内部类）：
声明为static的方法有以下几条限制： 
它们仅能调用其他的static 方法，反过来是可以的。 
它们只能访问static数据。 
它们不能以任何方式引用this或super。
不允许用来修饰局部变量

## 8.继承

继承是面向对象三大特征之一
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类

（1）继承是发生在多个类之间
（2）继承使用关键字extends
（3）JAVA只能单继承，允许多层继承
（4）被继承的类叫父类（超类），继承父类的类叫子类（派生类）
（5）在父类中的非私有属性和方法可以被子类继承
（6）protected（受保护的访问权限修饰符），修饰的属性或方法可以被子类继承
（7）构造方法不能被继承
（8）创建对象会调用构造方法，调用构造方法不一定就是创建对象
（9）实例化子类对象，会先调用父类的构造方法，如果父类中没有默认的构造方法，那么子类必须显示的通过super(...)来调用父类的带参构造方法，super也只能在子类构造方法中的第一句

继承的好处：
a、提高代码的复用性
b、提高代码的维护性
c、让类与类之间产生关系，是多态的前提
继承的缺点：增强了类与类之间的耦合性

## 9.方法的重写

在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。
在子类和父类中，重写方法后，在调用时，以创建的对象类型为准，会调用谁的方法。

重写特性：
a、发生在子父类中，方法重写的两个方法返回值、方法名、参数列表必须完全一致（子类重写父类的方法）
b、子类抛出的异常不能超过父类相应方法抛出的异常（子类异常不能大于父类异常）
c、子类方法的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)
d、父类中的方法若使用private、static、final任意修饰符修饰，那么，不能被子类重写

注：overloading与overriding的区别？

​	答：overloading：“重载”，参数和返回值可改变。

​		overriding：“覆盖”，重写父类的虚函数，参数的返回值必须与父类相同

​	重写overriding是父类与子类之间多态性的一种表现，重载overloading是一个类中多态性的一种表现。

## 10.super关键字

对父类的引用，使用super来调用父类的属性，方法和构造方法。

a、使用super调用父类中的属性，可以从父类实例处获得信息。
b、使用super调用父类中的方法，可以委托父类对象帮助完成某件事情。
c、使用super调用父类中的构造方法（super(实参)形式），必须在子类构造方法的第一条语句，调用父类中相应的构造方法，若不显示的写出来，默认调用父类的无参构造方法，比如：super();

## 11.final关键字

a、使用final关键字声明一个常量
当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的
b、使用final关键字声明一个方法
该方法为最终方法，且只能被子类继承，但是不能被子类重写。
c、使用final关键字声明一个类
该类就转变为最终类，没有子类的类，fianl修饰的类无法被继承。
d、在方法参数中使用final，在该方法内部不能修改参数的值（在内部类中详解）

## 12.抽象类

（1）很多具有相同特征和行为的对象可以抽象为一个类；很多具有相同特征和行为的类可以抽象为一个抽象类。
（2）使用abstract关键字声明的类为抽象类

抽象类的规则：
a、抽象类可以没有抽象方法，有抽象方法的类必须是抽象类
b、非抽象类继承抽象类必须实现所有抽象方法
c、抽象类可以继承抽象类，可以不实现父类抽象方法。
d、抽象类可以有方法实现和属性
e、抽象类不能被实例化
f、抽象类不能声明为final
g、抽象类可以有构造方法

## 13.接口

接口的使用规则：
（1）定义一个接口，使用interface关键字
（2）在一个接口中，只能定义常量、抽象方法，JDK1.8后可以定义默认的实现方法
（3）接口可以继承多个接口：extends xxx,xxx
（4）一个具体类实现接口使用implements关键字
（5）一个类可以实现多个接口
（6）抽象类实现接口可以不实现接口的方法
（7）在接口中定义的方法没有声明 访问修饰符，默认为public
（8）接口不能有构造方法
（9）接口不能被实例化
java8新增
（1）增加了default方法和static方法,这两种方法完全可以有方法体
（2）default方法属于实例,static方法属于类(接口)
（3）接口中的静态方法不会被继承,接口中的静态变量会被继承

## 14.多态性

多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

多态性我们大概可以分为两类：
（1）方法的重载与重写
（2）对象的多态性

//用父类的引用指向子类对象（用大的类型去接受小的类型，向上转型、自动转换）
Chicken home = new HomeChicken();

在编程时针对抽象类型的编写代码，称为面向抽象编程（或面向接口编程）父类通常都定义为抽象类、接口

对象的多态性：
对象多态性是从继承关系中的多个类而来，
向上转型：将子类实例转为父类引用
格式：父类 父类对象 = 子类实例 ； 自动转换
以基本数据类型操作为例：int i = ‘a' ;
（因为char的容量比int小，所以可以自动完成）

向下转型：将父类实例转为子类实例
格式：子类 子类对象 = （子类）父类实例 ；强制转换
以基本数据类型操作为例：char c = (char)97;
因为整型是4个字节比char 2个字节要大，所以需要强制完成
a、方法的重载与重写就是方法的多态性表现
b、多个子类就是父类中的多种形态
c、父类引用可以指向子类对象，自动转换
d、子类对象指向父类引用需要强制转换（注意：类型不对会报异常）
e、在实际开发中尽量使用父类引用（更利于扩展）

指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，
该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，
必定是使用子类中定义的这些方法（动态连接、动态调用）。
例如：
class A{
　　void fun1(){}
　　void fun2(){}
}

class B extends A{
　　void fun1(String a){} //重载fun1
　　void fun2(){} //重写fun2
}

class C{
　　public static void main(String[] args){
　　A a = new B();
　　a.fun1(); //这里会调用A类的fun1方法，由于向上转型，B的fun1(String a) 会被丢弃
　　a.fun2(); //这里调用B的fun2方法，由于是new 的B对象，而B重写了fun2，所以会调用B的fun2
}
}

对于面向对象而言，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性

java实现多态有三个必要条件：继承、重写、向上转型。
继承：在多态中必须存在有继承关系的子类和父类。
重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法

基于继承实现的多态
继承是通过重写父类的同一方法的几个不同子类来体现的
对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，
执行相同动作产生的行为也就不同。

基于接口实现的多态
指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。

## 15.instanceof关键字

instanceof是用于检查对象是否为指定的类型，通常在把父类引用强制转换为子类引用时要使用，以避免发生类型转换异常（ClassCastException）。

例如：

if(homeChicken instanceof Chicken){
　　//...
}

通过instanceof关键字，我们可以很方便的检查对象的类型，但如果一个父类的子类过多，这样的判断还是显得很繁琐，那么如何去设计一个父类呢？
a、父类通常情况下都设计为抽象类或接口，其中优先考虑接口，如接口不能满足才考虑抽象类。

b、一个具体的类尽可能不去继承另一个具体类，这样的好处是无需检查对象是否为父类的对象。

## 16.内部类

内部类就是在一个类的内部定义的类。
成员内部类：内部类对象依赖外部类对象而存在，即在创建一个普通内部类对象时首先需要创建其外部类对象
内部类对象可以访问外部类对象中所有访问权限的字段，同时，外部类对象也可以通过内部类的对象引用来访问内部类中定义的所有访问权限的字段
成员内部类格式如下：
class Outer {
　　class Inner{}
}
编译上述代码会产生两个文件：
Outer.class和Outer$Inner.class。

在外部创建内部类对象
内部类除了可以在外部类中产生实例化对象，也可以在外部类的外部来实例化。
那么，根据内部类生成的*.class文件：Outer$Inner.class
“$” 符号在程序运行时将替换成“.”
所以内部类的访问：通过“外部类.内部类”的形式表示。

Outer out = new Outer() ;// 产生外部类实例
Outer.Inner in = null; // 声明内部类对象
in = out.new Inner() ; // 实例化内部类对象

局部内部类
内部类可以作为一个类的成员外，还可以把类放在方法内定义（不常用，匿名内部类可以显示局部内部类的功能）。
在局部内部类里面可以访问外部类对象的所有访问权限的字段，而外部类却不能访问局部内部类中定义的字段
注意：
a、局部内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化。
b、局部内部类对象不能使用该内部类所在方法的非final局部变量。
class Outer {
　　public void doSomething(){
　　class Inner{
　　　　public void seeOuter(){}
　　}
　　}
}

静态内部类
在一个类内部定义一个静态内部类：
静态的含义是该内部类可以像其他静态成员一样，没有外部类对象时，也能够访问它。静态嵌套类仅能访问外部类的静态成员和方法。
静态内部类中也无法访问外部类的非静态成员
class Outer{
　　static class Inner{}
}
class Test {
　　public static void main(String[] args){
　　Outer.Inner n = new Outer.Inner();
}
}

匿名内部类
匿名内部类就是没有名字的内部类。
匿名内部类的三种情况：
（1）继承式的匿名内部类
（2）接口式的匿名内部类
（3）参数式的匿名内部类

在使用匿名内部类时，要记住以下几个原则：
（1）不能有构造方法，只能有一个实例。
（2）不能定义任何静态成员、静态方法。
（3）不能是public,protected,private,static。
（4）一定是在new的后面，用其隐含实现一个接口或继承一个类。
（5）匿名内部类为局部的，所以局部内部类的所有限制都对其生效

局部内部类访问局部变量必须用final修饰，为什么?
当调用这个方法时，局部变量如果没有用final修饰，他的生命周期和方法的生命周期是一样的，当方法被调用时会入栈，
方法结束后即弹栈，这个局部变量也会消失，那么如果局部内部类对象还没有马上消失想用这个局部变量，显然已无法使用了，
如果用final修饰会在类加载的时候进入常量池，即使方法弹栈，常量池的常量还在，也就可以继续使用了。

注意：在jdk1.8中取消了在局部内部类中使用的变量必须显示的使用final修饰，编译器默认会为这个变量加上final

内部类的作用
每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，
内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。

依赖外部类对象的：成员内部类，方法内部类，匿名内部类
静态内部类不依赖外部类的对象。所以，我们在项目中优先考虑选择静态内部类（不会产生内存泄露）