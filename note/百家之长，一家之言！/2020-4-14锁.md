# 				锁

![](C:\Users\14579\Pictures\笔记图\Java常用锁.png)

## 1.乐观锁和悲观锁

### 1.概念

​	对于同一数据的并发操作，**乐观锁**认为自己在操作数据时，不会有别的线程修改数据，所以不用给操作数据加锁。只需要在更新数据时，判断之前有没有别的线程更新过这个数据。没有--->将当前线程修改的数据写入；有--->根据不同的实现方式执行不同的操作（例如报错、自动重试等）。**悲观锁**认为自己在操作数据时，一定会有别的线程来修改数据，所以它会在回去数据时加锁，确保该数据不会被别的线程修改。（synchronized关键字和Lock的实现类都是悲观锁）

​	**Tips**：为什么乐观锁能在不锁定同步资源的情况下，实现正确的线程同步？

​		**答：**乐观锁的主要实现方式“CAS”技术（Compare And Swap），它是一种无锁算法（没有线程被阻塞）。需要读写的内存值V，进行比较的值A，要写入的值B。**当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。**一般情况下，“更新”是一个不断重试的操作。

- ABA问题：加版本号，JDK1.5提供了解决ABA问题的类。

- 循环时间长，开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。

- 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。

  Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

### 2.应用

乐观锁：读操作多的场景（不加锁确保性能好）

​	给表加一个版本号或时间戳字段实现，当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断当前版本信息与第一次取出来的版本值大小，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据，拒绝更新，让用户重新操作。（基于数据版本记录机制实现）

悲观锁：写操作多的场景（加锁确保准确性）

​	一般使用 select ...for update 对所选择的数据进行加锁处理，例如select * from account where name=”Max” for update， 这条sql 语句锁定了account 表中所有符合检索条件（name=”Max”）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。（基于数据库中的锁机制实现）

## 2.自旋锁和适应性自旋锁



![](C:\Users\14579\Pictures\笔记图\自旋锁or非自旋锁.png)

**注：**

​	自旋锁本身也有缺点，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会相当好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX：PreBlockSpin来更改），没有成功获得锁，就应当挂起线程。自旋锁的实现原理同样是CAS。JDK6中默认开启，并且引入适应性自旋锁。

​	自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源

## 3.无锁、偏向锁、轻量级锁和重量级锁（synchronized）

### 1.知识补充

synchronized是悲观锁，在操作同步资源前都要先加锁，这把锁就加在Java对象头里！